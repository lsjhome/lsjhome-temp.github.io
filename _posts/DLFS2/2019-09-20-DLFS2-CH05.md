---
layout: post
title: Chapter 05. RNN
comments: true
categories: [Deep Learning from Scratch 2]
tags: [Deep Learning, Machine Learning, NLP]
author: lsjhome



---

# Chapter 5 RNN

**피드포워드** 는 흐름이 단방향인 신경망을 말한다. 입력 신호가 다음 층(중간층)으로 전달되고, 그 신호를 받은 층은 그 다음 층으로 전달하고, 다시 다음 식으로... 식으로 한 방향으로만 신호가 전달된다.

피드포워드 신경망은 구성이 단순하여 구조를 이해하기 쉽고, 많은 문제에 응용할 수 있지만, 시계열 데이터를 잘 다루지 못한다.

## 5.1 확률과 언어 모델

### 5.1.1 word2vec을 확률 관점에서 바라보자

$w_{1}$, $w_{2}$ ,,, $$w_{T}$$ 라는 단어별로 표현되는 말뭉치를 생각해 보자. t번째 단어를 타깃으로, 그 전후 단어 (t-1번째와 t+1 번째)를 '맥락'으로 취급해 보자. 

![fig 5-1](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-1.png)

$$W_{t-1}$$와 $$W_{t+1}$$이 주어졌을 때 타깃이 $$w_{t}$$ 이 될 확률을 수식으로 나타내 보자.

![e 5-1](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-1.png)

CBOW 모델은 위 식의 사후 확률을 모델링한다. 이것이 윈도우 크기가 1일때의 CBOW 모델이다.

여기서 맥락을 좌우 대칭으로 하는 대신, 왼쪽 윈도우만으로 한정해 보자.

![fig 5-2](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-2.png)

왼쪽 두 단어만을 맥락으로 생각하면 아래와 같이 된다.

![e 5-2](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-2.png)

그런데 [식 5.2]의 표기를 사용하면, CBOW 모델이 다루는 손실 함수를 아래 식처럼 쓸 수 있다.

![e 5-3](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-3.png)

CBOW 모델의 학습으로 수행하는 일은 [식 5.3]의 손실 함수(정확히는 맒우치 전체의 손실 함수의 총합)을 최소화하는 가중치 매개변수를 찾는 일이다. 이러한 가중치 매개변수가 발견되면 CBOW 모델은 맥락으로부터 타깃을 더 정확하게 추측할 수 있게 된다.

이처럼 CBOW 모델을 학습시키는 본래 목적은 맥락으로부터 타깃을 정확하게 추측하는 것이다. 이 목적을 위해 학습을 진행하면, (그 부산물로) 단어의 의미가 인코딩된 '단어의 분산 표현'을 얻을 수 있다.

그럼 CBOW 모델의 본래 목적인 '맥락으로부터 타깃을 추측하는 것'은 어디에 이용할 수 있을까? 여기서 언어 모델이 등장한다.

### 5.1.2 언어 모델

**언어 모델** 은 단어 나열에 확률을 부여한다. 특정한 단어의 시퀀스에 대해서, 그 시퀀스가 일어날 가능성이 어느 정도인지(얼마나 자연스러운 단어 순서인지)를 확률로 평가하는 것이다. 예컨대 "you say goodbye"라는 단어 시퀀스에는 높은 확률을 출력하고, "you say good die"에는 낮은 확률ㅇ르 출력하는 것이 일종의 언어 모델이다.

이 언어 모델은 다양하게 응용할 수 있다. 가령 음성 인식 시스템의 경우, 사람의 음성으로부터 몇 개의 문장을 후보로 생성하고, 언어 모델을 사용하여 후보 문장이 '문장으로써 자연스러운지'를 기준으로 순서를 매길 수 있다.

또한 언어 모델은 새로운 문장을 생성하는 생성하는 용도가 될 수도 있다. 언어 모델은 단어의 자연스러움을 확률적으로 평가할 수 있으므로, 확률분포에 따라 다음으로 적당한 단어를 '자아낼'(샘플링) 수 있기 때문이다.

언어 모델을 수식으로 설명하면 다음과 같다.

![e 5-4](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-4.png)

위의 식에서 알 수 있듯이, 목적으로 하는 동시 확률 $$P(w_{1}, ..., w_{m}) $$ 은 사후 확률의 총 곱인 $$ \prod P(w_{t}| w_{1}, w_{2}, ... w_{t-1})$$ 으로 대표될 수 있다. 여기서 주목할 것은 이 사후 확률은 타깃 단어보다 왼쪽에 있는 모든 단어를 맥락(조건)으로 했을 때의 확률이라는 것이다.

![fig 5-3](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-3.png)

즉,  $$P(w_{1}, ..., w_{m}) $$ 이라는 확률을 얻는 것이 목표이고, 이 확률을 계싼할 수 있따면 언어 모델의 동시 확률 $$P(w_{1}, w_{2}, w_{3}, ... w_{m})$$ 을 구할 수 있다.

> $$P(w_{t}| w_{1}, w_{2}, ... w_{t-1})$$ 을 나타내는 모델은 **조건부 언어 모델**(Conditional Language Model)이라고 한다. 한편, 이를 '언어 모델'이라고 하는 경우도 많다.

### 5.1.3 CBOW 모델은 언어 모델로?

그렇다면 word2vec의 CBOW 모델을 언어 모델로 적용하려면 어떻게 해야 할까? 이는 맥락의 크기를 특정 값으로 한정하여 근사적으로 나타낼 수 있다. 수식으로는 다음과 같다.

![e 5-8](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-8.png)

여기서는 맥락을 왼쪽 2개의 단어로 한정한다.

> 머신러닝이나 통계학에서는 **마르코프 연쇄**(Markov Chain) 또는 **마르코프 모델**(Markov Model)이라는 말을 자주 사용한다. 마르코프 연쇄란 미래의 상태가 현재 상태에만 의존해 결정되는 것을 뜻한다. 또한 이 사상의 확률이 '그 직전' N개의 사건에만 의존할 때, 이를 'N층 마르코프 연쇄' 라고 한다. 이번 예는 직전 2개의 단어에만 의존해 다음 단어가 정해지는 모델이므로 '2층 마르코프 연쇄' 라고 부를 수 있다.

이 예에서는 맥락으로 2개의 단어를 이용했지만, 이 맥락의 크기는 임의 길이로 설정할 수 있다. 그러나 임의 길이로 설정할 수 있다고 해도, 결국 특정 길이로 '고정' 된다. 가령 왼쪽 10개의 단어를 맥락으로 CBOW 모델을 만든다면, 그 맥락보다 더 왼쪽에 있는 단어의 정보는 무시된다.

![fig 5-4](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-4.png)

이 문제에서 정답을 구하려면 "?"로부터 18번째나 앞에 있는 "Tom"을 기억해야 한다. 만약 CBOW 모델의 맥락이 10개까지였다면 이 문제에 재대로 답할 수 없을 것이다.

CBOW 모델의 맥락 크기를 키운다고 해도, CBOW모델에는 맥락 안의 단어 순서가 무시된다는 한계가 있다.

> CBOW란 Continuous bag-of-words의 약어이다. bag-of-words란 '가방 안의 단어'를 뜻하는데, 여기에서는 가방 속의 단어 '순서'는 무시된다는 뜻도 내포한다.

맥락의 단어 순서가 무시되는 문제의 구체적인 예를 보자. 예컨대 맥락으로 2개의 단어를 다루는 경우, CBOW 모델에서는 이 2개의 단어 벡터의 '합'이 은닉층에 온다.

![fig 5-5](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-5.png)

즉 왼쪽 그림과 같이 은닉층에서는 단어 벡터들이 더해지므로 맥락 단어의 순서는 무시된다.

이상적으로는 맥락의 단어 순서도 고려한 모델이 바람직할 것이다. 이를 위해 오른쪽처럼 맥락의 단어 벡털르 은닉층에서 **연결** 하는 방식을 생각할 수 있따. 실제, 신경 확률론적 언어 모델에서 제안한 모델은 이 방식을 취한다. 그러나 연결하는 방식을 취하면 맥락의 크기에 비례해 가중치 매개변수도 늘어나게 된다. 물론, 매개변수가 증가한다는 것은 환영할만한 일이 아니다.

여기서 RNN이 등장한다. RNN은 맥락이 아무리 길더라도 그 맥락의 정보를 기억하는 메커니즘을 갖추고 있다. 그래서 RNN을 사용하면 아무리 긴 시계열 데이터에라도 대응할 수 있다.

## 5.2 RNN이란

> Recurrent Neural Network는 우리말로 '순환 신경망'으로 번역한다. 한편 Recursive N/eural Network 라는 신경망도 있다. 이는 주로 트리 구조의 데이터를 처리하기 위한 신경망으로, 순환 신경망과는 다르다.

### 5.2.1 순환하는 신경망

"순환한다"에는 어떤 의미가 있을까? 물론 "반복해서 되돌아감"을 의미한다. 원래 한 지점에서 시작한 것이, 시간을 지나 다시 원래 장소로 돌아오는 것, 그리고 이 과정을 반복하는 것이 바로 "순환" 이다.

RNN의 특징은, 순환하는 경로(닫힌 경로)가 있다는 것이다. 이 순환 경로를 따라 데이터는 끊임없이 순환할 수 있다. 그리고 데이터가 순환되기 때문에 과거의 정보를 기억하는 동시에 최신 데이터로 갱신될 수 있는 것이다.

RNN에 이용되는 계층을 'RNN 계층'이라 한다. RNN 계층은 아래처럼 그릴 수 있다.

![fig 5-6](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-6.png)

위 그림에서 RNN 계층은 순환하는 경로를 포함한다. 이 순환 경로를 따라 데이터를 계층 안에서 순환시킬 수 있다. 또한 $$x_{t}$$ 를 입력받는데, t는 시각을 뜻한다. 이는 시계열 데이터 ($$x_{0}, x_{1}, .., x_{t}, ...$$)가 RNN 계층에 입력됨을 표현한 것이다. 그리고 이 입력에 대응하여 ($$h_{0}, h_{1}, .., h_{t}, ...$$) 가 출력된다.

또한, 각 시각에 입력되는 $$x_{t}$$ 는 벡터라고 가정한다. 문장(단어 순서)을 다루는 경우를 예를 들자면, 각 단어의 분산 표현(단어 벡터)이 $$x_{t}$$가 되며, 이 분산 표현이 순서대로 하나씩 RNN 계층에 입력되는 것이다.

또한, 각 시각에 입력되는 $$x_{t}$$는 벡터라고 가정하자. 문장(단어 순서)을 다루는 경우를 예로 든다면, 각 단어의 분산 표현(단어 벡터)이 $$x_{t}$$가 되며, 이 분산 표현이 순서대로 하나씩 RNN 계층에 입력되는 것이다.

> 위 그림을 보면 출력이 2개로 분기하고 있음을 알 수 있다. 여기서 말하는 '분기'란 같은 것이 복제되어 분기함을 의미한다. 그리고 이렇게 분기도니 출력 중 하나가 자기 자신에 입력된다. (즉 순환한다.)

![fig 5-7](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-7.png)

### 5.2.2 순환 구조 펼치기

RNN 계층의 순환 구조에 대해 살펴보자. 

![fig 5-8](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-8.png)

위 그림에서 보듯, RNN 계층의 순호나 구조를 펼침으로써 오른쪽으로 성장하는 긴 신경망으로 변신시킬 수 있다. 지금까지 본 피드포워드 신경망과 같은 구조이다. 지금까지 본 피드포워드 신경망과 같은 구조이다. (피드포워드에서는 데이터가 한 방향으로만 흐른다). 다만, [그림 5-8]에 등장하는 다수의 RNN 계층 모두가 실제로는 '같은 계층'인 것이 지금까지와의 신경망과의 차이다.

> 시계열 데이터는 시간 방향으로 데이터가 나열된다. 따라서 시계열 데이터의 인덱스를 가리킬 때는 "시각"이라는 용어를 사용한다. (가령 시각 t의 입력 데이터 $$x_{t}$$ 등) 자연어의 경우에도 't번째 단어'나 't번째 RNN 계층' 이라는 표현도 사용하지만, '시각 t의 단어'나 '시각 t의 RNN 계층'처럼 표현하기도 한다.

각 시각의 RNN 계층은 그 계층으로부터 입력과 1개 전의 RNN 계층으로부터의 출력을 받는다. 그리고 이 두 정보를 바탕으로 현 시각의 출력을 계산한다. 이때 수행하는 계산의 수식은 다음과 같다. 

![e 5-9](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-9.png)

우선 위 식에 쓰인 기호들을 설명해 보자면, RNN에는 가중치가 2개 있다. 하나는 입력 **x** 를 출력 **h** 로 변환하기 위한 가중치 $$W_{x}$$ 이고, 다른 하나는 1개의 RNN 출력을 다음 시각의 출력으로 변환하기 위한 가중치 $$W_{h}$$ 이다. 또한 편향 b도 있다. 참고로 $$h_{t-1}$$ 과 $$x_{t}$$는 행 벡터이다.

현재의 출력($$h_{t}$$)는 한 시각 이전 출력 $$h_{t-1}$$ 에 기초해 계산됨을 알 수 있다. 다른 관점으로 보면, RNN은 h라는 '상태'를 가지고 있으며, 위 식의 형태로 갱신된다고 해석할 수 있다. 그래서 RNN 계층을 '상태를 가지는 계층' 혹은 '메모리(기억력)'가 있는 계층이라 한다.

> RNN의 h는 '상태'를 기억해 시각이 1 스텝(1단위) 진행될 때마다 위의 식의 형태로 갱신된다. 많은 문헌에서 RNN의 출력 $$h_{t}$$ 를 은닉 상태(hidden state) 혹은 은닉 상태 벡터(hidden state vector)라고 부른다. 이 책에서도 RNN의 출력 $$h_{t}$$를 '은닉 상태' 또는 '은닉 상태 벡터'로 부르겠다.

![fig 5-9](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-9.png)

이 책에서는 오른쪽 그림과 같이 하나의 출력이 분기하는 것임을 명시한다.

### 5.2.3 BPTT

RNN 계층은 가로로 펼친 신경망으로 간주할 수 있다. 따라서 학습도 보통의 신경망과 같은 순서로 진행할 수 있다. 아래 그림과 같이 된다.

![fig 5-10](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-10.png)

여기서도 일반적인 오차역전파법을 적용할 수 있다. 먼저 순전파를 수행하고, 이어서 역전파를 수행하여 원하는 기울기를 구할 수 있다. 여기서의 오차역전파법은 '시간 방향으로 펼친 신경망의 오차 역전파법' 이란 뜻으로, **BPTT**(Backpropagation Through Time) 이라고 한다.

하지만 긴 시계열 데이터를 학습할 때 문제가 있다. 시계열 데이터의 시간 크기가 커지는 것에 비례하여 BPTT가 소비하는 컴퓨팅 자원도 증가하기 때문이다. 시간 크기가 커지면 역전파 시의 기울기가 불안정해지는 것도 문제이다.

> BPTT를 이용해 기울기를 구하려면, 매 시각 RNN 계층의 중간 데이터를 메모리에 유지하지 않으면 안 된다. 따라서 시계열 데이터가 길어짐에 따라 (계산량 뿐 아니라) 메모리 사용량도 증가하게 된다.

### 5.2.4 Truncated BPTT

큰 시계열 데이터를 취급할 때에는 흔히 신경망 연결을 적당한 길이로 끊는다. 시간축 방향으로 너무 길어진 신경망을 적당한 지점에서 잘라내어 작은 신경망 여러 개로 만든다는 아이디어다. 그리고 이 잘라낸 작은 신경망에서 오차역전파법을 수행한다. 이것이 바로 **Truncated BPTT** 라는 기법이다.

> Truncated BPTT는 적당한 길이로 '잘라낸' 오차역전파법 이라는 뜻이다.

제대로 구현하려면 '역전파'의 연결만 끊으면 된다. 순전파의 연결은 반드시 그대로 유지해야 한다. 즉, 순전파의 흐름은 끊어지지 않고 전파된다. 다만 역전파의 연결은 적당한 길이로 잘라내, 그 잘라낸 신경망 단위로 학습을 수행한다.

가령 Truncated BPTT를 구체적인 예를 통해 살펴보자. 길이가 1000인 시계열 데이터를 가정해 보자. 자연어 문제에서라면 단어 1000개에 해당하는 말뭉치에 해당한다. 여러 문장을 연결한 것을 하나의 큰 시계열 데이터로 취급하자. 

그런데 길이가 1000인 시계열 데이터를 다루면서 RNN 계층을 펼치면 계층이 가로로 1000개나 늘어난 신경망이 된다. 물론 계층이 아무리 늘어나도 오차역전파법으로 기울기를 계산할 수는 있다. 다만 너무 길면 계산량과 메모리 사용량 등이 문제가 된다. 또한 계층이 길어짐에 따라 신경망을 하나 통괗ㄹ 때마다 기울기 값이 조금씩 작아져서, 이전 시각 t까지 역전파되기 전에 0이 되어 소멸할 수 있다. 이런 이유로 아래 그림처럼 길게 뻗은 신경망의 역전파에서는 연결을 적당한 길이로 끊는다.

![fig 5-11](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-11.png)

위 그림에서는 RNN 계층을 길이 10개 단위로 학습할 수 있도록 역전파의 연결을 끊었다. 이처럼 역전파의 연결을 잘라버리면, 그보다 미래의 데이터에 대해서는 생각할 필요가 없어진다. 따라서 각각의 블록 단위로, 미래의 블록과는 독립적으로 오차역전파법을 완결시킬 수 있다.

여기서 중요한 점은 역전파의 연결은 끊어지지만, 순전파의 연결은 끊기지 않는다는 것이다. 그러므로 RNN을 학습시킬 때는 순전파가 연결된다는 것을 고려해서, 데이터를 '순서대로' 입력해야 한다. 

> 지금까지 본 신경망에서는 미니배치 학습을 수행할 때 데이터를 무작위로 선택해 입력했다. 하지만 RNN에서 Truncated BPTT를 수행할 때는 데이터를 '순서대로' 입력해야 한다.

이제 Truncated BPTT 방식으로 RNN을 학습시켜 보자. 가장 먼저 할 일은 첫번째 블록 데이터($$x_{0}, x_{1}, ... x_{9}$$)를 RNN 계층에 제공하는 것이다. 아래 그림과 같다.

![fig 5-12](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-12.png)

먼저 순전파를 수행하고, 그 다음 역전파를 수행한다. 이렇게 하여 원하는 기울기를 구할 수 있다. 이어서 다음 블록의 입력 데이터($$x_{10}$$ 에서 $$x_{19}$$)를 입력해 오차역전파법을 수행한다.

![fig 5-13](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-13.png)

첫 번째 블록과 마찬가지로 순전파를 수행한 다음, 역전파를 수행한다. 그리고 순전파 계산에는 앞 블록의 마지막 은닉 승태인 $$h_{9}$$ 가 필요하다.

같은 요령으로, 3번째 블록을 대상으로 학습을 수행한다. 이때도 두 번째 블록의 마지막 은닉 상태($$h_{19}$$)를 이용할 수 있다. 이처럼 RNN 학습에서는 데이터를 순서대로 입력하며, 은닉 승태를 계승하면서 학습을 수행한다. 지금까지의 설명으로 RNN 학습의 흐름은 아래 그림처럼 되는 것을 확인할 수 있다.

![fig 5-14](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-14.png)

Truncated BPTT에서는 데이터를 순서대로 입력해 학습한다. 이런 식으로 순전파의 연결을 유지하면서 블록 단위로 오차역전파법을 적용할 수 있다.

### 5.2.5 Truncated BPTT의 미니배치 학습

지금까지는 Truncated BPTT 이야기에서는 미니배치 학습 시 가각ㄱ의 미니배치가 어떤 식으로 이뤄지는지는 생각하지 않았다. 즉, 지금까지의 이야기는 미니배치 수가 1일때 적당하다.

길이가 1000인 시계열 데이터에 대해서, 시각의 길이를 10개 단위로 잘라 Truncated BPTT로 학습하는 경우를 예로 설명해 보자. 그러면 이때 미니배치의 수를 2개로 지정해서 학습하려면 어떻게 해야 할까?

![fig 5-15](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-15.png)

이처럼 미니배치 학습을 수행할 때는 각 미티배치의 시작 위치를 오프셋으로 옮겨준 후 순서대로 제공하면 된다. 또한 데이터를 순서대로 입력하다가 끝에 도달하면 다시 처음부터 입력하면 된다.

### 5.3 RNN 구현

![fig 5-16](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-16.png)

길이가 T인 시계열 데이터를 받늗나. 그리고 각 시각은 은닉 상태를 T개 출력한다. 그리고 모듈화를 생각해, 옆으로 성장한 [그림 5-16]의 산경망을 '하나의 계층'으로 구현한다. 그림으로 보면 [그림 5-17]처럼 된다. 

![fig 5-17 2](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-17 2.png)

입력과 출력을 각각 하나로 묶으면 옆으로 늘어선 일련의 계층을 하나의 계층으로 간주할 수 있다. 즉 ($$x_{0}, x_{1}, x_{2}, ... x_{T-1}$$) 을 묶은 **xs** 을 입력하면 ($$h_{0}, h_{1}, h_{2}, ... h_{T-1}$$) 을 묶은 **hs** 를 출력하는 단일 계층으로 볼 수 있다. 이때 Time RNN 계층 내에서 한 단계의 작업을 수행하는 계층을 "RNN 계층"이라고 하고, T개 단계분의 작업을 한꺼번에 처리하는 계층을 "Time RNN 계층" 이라 한다. 

> Time RNN 같이 시계열 데이터를 한꺼번에 처리하는 계층에는 앞에 'Time'을 붙인다. 이는 이 책 독자적인 명명규칙이다. 가령 Time Affine 계층과 Time Embedding 계층의 경우 시계열 데이터를 한꺼번에 처리한다.

먼저 RNN의 한 단계를 처리하는 클래스를 RNN이란 이름으로 구현하고, 이 RNN 클래스를 구현해 T개 단계의 처리를 한꺼번에 수행하는 계층을 TimeRNN 이라는 이름의 클래스로 완성시키자.

### 5.3.1 RNN 계층 구현

RNN 처리를 한 단계만 수행하는 RNN 클래스부터 구현해보자. RNN의 순전파는 아래 식과 같다.

![e 5-10](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/e 5-10.png)

여기에서 우리는 데이터를 미니배치로 모아 처리한다. 따라서 $$x_{t}$$ 와 $$h_{t}$$ 에는 각 샘플 데이터를 행 방향에 저장한다. 한편, 행렬을 계산할 때에는 행렬의 '형상 확인'이 중요하다. 미니배치 크기가 N, 입력 벡터의 차원 수가 D, 은닉 상태의 차원 수가 H라면, 지금 계산에서의 형상 확인은 아래와 같다.

![fig 5-18](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-18.png)

그림에서 보듯, 행렬의 형상 확인을 수행함으로써, 올바로 구현되었는지를 확인할 수 있다. 그럼 이상을 바탕으로 RNN 클래스의 초기화와 순전파 메서드를 구현해 보자.

```python
class RNN:
    def __init__(self, Wx, Wh, b):
        self.params = [Wx, Wh, b]
        self.grads = [np.zeros_like(Wx), np.zeros_like(Wh), np.zeros_like(b)]
        self.cache = None

    def forward(self, x, h_prev):
        Wx, Wh, b = self.params
        t = np.dot(h_prev, Wh) + np.dot(x, Wx) + b
        h_next = np.tanh(t)

        self.cache = (x, h_prev, h_next)
        return h_next
```

RNN의 초기화 메서드는 가중치 2개와 편향 1개를 인수로 받는다. 여기에서는 인수로 받은 매개변수를 인스턴스 변수 params에 리스트로 저장한다. 그리고 각 매개변수에 대응하는 형태로 기울기를 초기화한 후 grads에 저장한다. 마지막으로 역전파 계산시 사용하는 중간 값을 담을 cache를 None으로 초기화한다.

순전파 forward(x, h\_prev)에서는 인수 2개인 아래로부터 입력 x와 왼쪽으로부터 입력 h\_prev를 받는다. 그 다음은 식을 그대로 코드로 옮긴다.

하나 앞의 RNN 계층으로부터 받는 입력이 h\_prev이고, 현 시각 RNN 계층으로부터의 출력은 h\_next 이다. 

순전파를 계산 그래프로 나타내면 아래와 같다.

![fig 5-19](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-19.png)

역전파의 경우 아래와 같다.

![fig 5-20](/Users/jin/projects/lsjhome.github.io/assets/img/dlfs2/deep_learning_2_images/fig 5-20.png)

이제 RNN 계층의 backward() 코드를 살펴보자. 다음과 같이 구현될 수 있다.

```python
class RNN:
    # ...
		# ...
		# ...
    def backward(self, dh_next):
        Wx, Wh, b = self.params
        x, h_prev, h_next = self.cache

        dt = dh_next * (1 - h_next ** 2)
        db = np.sum(dt, axis=0)
        dWh = np.dot(h_prev.T, dt)
        dh_prev = np.dot(dt, Wh.T)
        dWx = np.dot(x.T, dt)
        dx = np.dot(dt, Wx.T)

        self.grads[0][...] = dWx
        self.grads[1][...] = dWh
        self.grads[2][...] = db

        return dx, dh_prev
```

### 5.3.2 Time RNN 계층 구현





